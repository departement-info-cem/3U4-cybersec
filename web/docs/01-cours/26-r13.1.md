---
id: r13.1
title: Rencontre 13.1 - Chiffrement asym√©trique
sidebar_label: 13.1 - Chiffrement asym√©trique
draft: false
hide_table_of_contents: false
---

# Chiffrement asym√©trique

## Diff√©rence avec le chiffrement sym√©trique

Dans le chiffrement sym√©trique, la m√™me cl√© est utilis√©e pour chiffrer et d√©chiffrer. Le probl√®me majeur est: comment partager cette cl√© de mani√®re s√©curis√©e?

Le chiffrement asym√©trique r√©sout ce probl√®me en utilisant **deux cl√©s diff√©rentes**:
- Une **cl√© publique** pour chiffrer (peut √™tre partag√©e avec tout le monde)
- Une **cl√© priv√©e** pour d√©chiffrer (doit rester secr√®te)

## Principe de fonctionnement

Utiliser un algo asym√©trique avec une cl√© publique de chiffrement et une priv√©e pour le d√©chiffrement:
- l'application peut chiffrer les mots de passe avec la cl√© publique >> voir JeanLouisEtFils dans le dossier **asym**
- le d√©chiffrement n√©cessite une cl√© priv√©e >> voir corpoDecryptor dans le dossier **asym**
- la cl√© priv√©e est plus complexe et en g√©n√©ral reli√©e par un probl√®me de calcul tr√®s difficile 
- on utilise ici l'algorithme RSA

## Lien math√©matique entre cl√©s

Exemple de lien entre cl√© priv√©e et publique:
- on tire 2 nombres premiers tr√®s grands x et y
- la cl√© publique est **""+x*y**
- la cl√© priv√©e est **x +":"+y**
- il est tr√®s difficile de trouver x et y √† partir de x*y mais tr√®s facile de v√©rifier que x*y est bien √©gal √† la cl√© publique

C'est ce qu'on appelle un **probl√®me √† sens unique**: facile √† calculer dans un sens, tr√®s difficile dans l'autre.

## Le cas classique du client-serveur

1. L'application cliente envoie les donn√©es au serveur, la s√©curit√© des donn√©es repose sur HTTPS (crypto asym√©trique).
2. Le serveur chiffre (sym√©trique) les donn√©es avant de les stocker en BD, la s√©curit√© repose sur le secret de la cl√©.

## Avantages et inconv√©nients

### Avantages
- Pas besoin de partager la cl√© secr√®te
- Permet la signature num√©rique
- Utilis√© pour HTTPS, SSH, etc.

### Inconv√©nients
- Beaucoup plus lent que le chiffrement sym√©trique
- Cl√©s plus longues n√©cessaires pour la m√™me s√©curit√©
- Plus complexe √† impl√©menter

---

## Application pratique : Le handshake HTTPS

Dans la vraie vie, on utilise **les deux types de chiffrement ensemble** pour combiner leurs avantages !

### Comment √ßa fonctionne

```mermaid
sequenceDiagram
    participant C as Client (Navigateur)
    participant S as Serveur Web
    participant I as Intercepteur üëÅÔ∏è
    
    Note over C,S: 1. Handshake - Chiffrement Asym√©trique
    S->>C: Voici ma cl√© publique RSA üîì
    I->>I: J'ai intercept√© la cl√© publique<br/>(mais √ßa ne sert √† rien!)
    
    C->>C: G√©n√®re une cl√© sym√©trique<br/>al√©atoire (ex: AES)
    C->>S: Cl√© sym√©trique chiffr√©e<br/>avec cl√© publique RSA üîí
    I->>I: J'ai intercept√© le message chiffr√©<br/>(mais je ne peux pas le d√©chiffrer<br/>sans la cl√© priv√©e!)
    
    S->>S: D√©chiffre avec cl√© priv√©e RSA üîë<br/>pour obtenir la cl√© sym√©trique
    
    Note over C,S: 2. Communication - Chiffrement Sym√©trique
    C->>S: Donn√©es chiffr√©es avec AES üîí
    S->>C: R√©ponse chiffr√©e avec AES üîí
    I->>I: Impossible de d√©chiffrer<br/>sans la cl√© sym√©trique!
```

### Pourquoi cette approche hybride ?

1. **Asym√©trique pour l'√©change de cl√©** : S√©curis√©, pas besoin de partager un secret √† l'avance
2. **Sym√©trique pour les donn√©es** : Rapide, efficace pour de gros volumes de donn√©es

### S√©curit√©

M√™me si un attaquant intercepte tout le trafic :
- Il obtient la cl√© publique (normal, elle est publique !)
- Il voit la cl√© sym√©trique chiffr√©e (mais ne peut pas la d√©chiffrer sans la cl√© priv√©e)
- Il voit les donn√©es chiffr√©es (mais ne peut pas les d√©chiffrer sans la cl√© sym√©trique)

**R√©sultat** : Toute la communication reste s√©curis√©e ! üîê


---

# Exercices et CTF

## Exercice: Comprendre RSA et la g√©n√©ration de cl√©s

### Pourquoi on ne peut pas juste inventer des cl√©s RSA?

Contrairement au chiffrement sym√©trique o√π une cl√© peut √™tre n'importe quelle cha√Æne de caract√®res (m√™me si ce n'est pas recommand√©), les cl√©s RSA ont une structure math√©matique pr√©cise:

1. Les cl√©s RSA sont bas√©es sur deux nombres premiers tr√®s grands (p et q)
2. La cl√© publique contient le module n = p √ó q et un exposant e
3. La cl√© priv√©e contient les facteurs premiers p et q (ou d'autres param√®tres calcul√©s √† partir d'eux)
4. Il existe une relation math√©matique stricte entre cl√© publique et priv√©e

**Ce qui NE marche PAS**:
```csharp
// ‚ùå FAUX - On ne peut pas juste mettre du Base64 al√©atoire
string clePublique = "SGVsbG9Xb3JsZA==";  // Juste du texte encod√©
string clePrivee = "TW9uU2VjcmV0";        // √áa ne veut rien dire en RSA!
```

**Ce qui marche**:
```csharp
// ‚úÖ CORRECT - Utiliser RSA pour g√©n√©rer les cl√©s
using (var rsa = RSA.Create(2048))  // 2048 bits de s√©curit√©
{
    string clePublique = rsa.ToXmlString(false);  // Cl√© publique en XML
    string clePrivee = rsa.ToXmlString(true);     // Cl√© priv√©e en XML
}
```

### D√©monstration du lien math√©matique

Les cl√©s sont li√©es par des propri√©t√©s math√©matiques:
- Ce qui est chiffr√© avec la cl√© publique ne peut √™tre d√©chiffr√© qu'avec la cl√© priv√©e correspondante
- Les cl√©s g√©n√©r√©es al√©atoirement ne fonctionneront pas ensemble
- Si vous essayez d'utiliser une "fausse" cl√©, vous obtiendrez des erreurs ou du charabia

---

## üö© CTF-implemente-rsa (5 points)

üìÑ **Fichier de remise**: Un repo GitHub avec votre code + `ctf-implemente-rsa.md`

**Objectif**: Cr√©er une application console .NET compl√®te qui d√©montre le chiffrement/d√©chiffrement RSA de bout en bout, en vous inspirant de JeanLouisEtFils et corpoDecryptor asym√©triques.

### Pr√©paration: Explorer les applications existantes

Avant de commencer, explorez les applications du dossier **asym** :
- **JeanLouisEtFilsAsym** : L'application qui chiffre avec la cl√© publique
- **corpoDecryptor (version asym)** : L'application qui d√©chiffre avec la cl√© priv√©e

**√Ä faire** :
1. D√©compilez les deux applications avec dotPeek ou ILSpy
2. Identifiez comment les cl√©s sont g√©n√©r√©es et utilis√©es
3. Rep√©rez les m√©thodes de chiffrement et d√©chiffrement
4. Observez le format des cl√©s (XML) et comment elles sont manipul√©es

:::warning Attention
Ne copiez pas le code tel quel ! Utilisez-le comme **r√©f√©rence** pour comprendre comment RSA fonctionne en .NET, puis impl√©mentez votre propre solution.
:::

### Votre mission

Cr√©ez une application console en C# qui contient:

#### 1. Une classe `RsaCrypto` avec les m√©thodes suivantes:

```csharp
public class RsaCrypto
{
    // G√©n√®re une paire de cl√©s RSA (publique + priv√©e)
    public (string publicKey, string privateKey) GenerateKeys(int keySize = 2048);
    
    // Chiffre un texte avec la cl√© publique
    public string Encrypt(string plainText, string publicKey);
    
    // D√©chiffre un texte avec la cl√© priv√©e
    public string Decrypt(string encryptedText, string privateKey);
}
```

#### 2. Un `Main()` qui d√©montre:

```csharp
static void Main(string[] args)
{
    var crypto = new RsaCrypto();
    
    // 1. G√©n√©ration des cl√©s
    var (publicKey, privateKey) = crypto.GenerateKeys();
    Console.WriteLine("=== Cl√©s g√©n√©r√©es ===");
    Console.WriteLine($"Cl√© publique: {publicKey.Substring(0, 100)}...");
    Console.WriteLine($"Cl√© priv√©e: {privateKey.Substring(0, 100)}...");
    
    // 2. Chiffrement
    string message = "Mon mot de passe secret: P@ssw0rd123!";
    string encrypted = crypto.Encrypt(message, publicKey);
    Console.WriteLine($"\nMessage original: {message}");
    Console.WriteLine($"Message chiffr√©: {encrypted}");
    
    // 3. D√©chiffrement
    string decrypted = crypto.Decrypt(encrypted, privateKey);
    Console.WriteLine($"Message d√©chiffr√©: {decrypted}");
    
    // 4. D√©monstration de l'√©chec avec une mauvaise cl√©
    DemontreMauvaiseCle(crypto, encrypted);
}
```

#### 3. Une d√©monstration que les "fausses cl√©s" ne marchent pas:

```csharp
static void DemontreMauvaiseCle(RsaCrypto crypto, string encrypted)
{
    Console.WriteLine("\n=== Test avec une fausse cl√© ===");
    
    // G√©n√©rer une autre paire de cl√©s
    var (_, wrongPrivateKey) = crypto.GenerateKeys();
    
    try
    {
        string result = crypto.Decrypt(encrypted, wrongPrivateKey);
        Console.WriteLine("‚ùå Erreur: la d√©cryption a r√©ussi avec la mauvaise cl√©!");
    }
    catch (Exception ex)
    {
        Console.WriteLine("‚úÖ Comme pr√©vu, la d√©cryption √©choue avec la mauvaise cl√©");
        Console.WriteLine($"Erreur: {ex.Message}");
    }
}
```

### Ce qu'il faut remettre

1. Votre code source complet sur GitHub
2. Un fichier `ctf-implemente-rsa.md` contenant:
   - Le lien vers votre repo GitHub
   - Des screenshots de l'ex√©cution montrant:
     - La g√©n√©ration des cl√©s
     - Le chiffrement d'un message
     - Le d√©chiffrement r√©ussi
     - L'√©chec avec une mauvaise cl√©
   - Explication de pourquoi on ne peut pas juste "inventer" des cl√©s RSA
   - Ce que vous avez appris en explorant JeanLouisEtFilsAsym et corpoDecryptor

:::tip Indices pour l'exploration
- Cherchez les classes ou m√©thodes contenant "RSA" ou "Crypto" dans le code d√©compil√©
- Regardez comment `ToXmlString()` et `FromXmlString()` sont utilis√©s
- Observez la gestion des exceptions lors du d√©chiffrement
- Notez comment le texte est converti en bytes puis en Base64
:::

:::tip Ressources utiles
- [Documentation RSA .NET](https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.rsa)
- [RSA Example in C#](https://learn.microsoft.com/en-us/dotnet/standard/security/cryptographic-services)
- Les applications JeanLouisEtFilsAsym et corpoDecryptor (dossier asym) comme r√©f√©rence
:::

---

## üö© CTF-cle-publique (1 point)

üìÑ **Fichier de remise**: `ctf-cle-publique.md`

**Objectif**: Extraire la cl√© publique RSA depuis l'ex√©cutable JeanLouisEtFilsAsym.

**Votre mission**:
1. T√©l√©chargez l'application JeanLouisEtFilsAsym (dossier asym)
2. Utilisez un d√©compilateur .NET (dotPeek, ILSpy) pour analyser le code
3. Trouvez la **cl√© publique RSA** utilis√©e pour le chiffrement

:::info Format de la cl√©
Les cl√©s RSA en .NET sont souvent au format XML ou PEM. Cherchez des balises comme `<RSAKeyValue>` ou des m√©thodes qui importent/exportent des cl√©s.
:::

**R√©compense**: 1 point au tableau des scores.

**√Ä noter dans votre rapport**:
- La cl√© publique compl√®te (format XML ou PEM)
- La taille de la cl√© en bits (ex: 2048, 4096)
- Le fichier source o√π vous l'avez trouv√©e

---

## üö© CTF-decrypt-asym (3 points)

üìÑ **Fichier de remise**: `ctf-decrypt-asym.md`

**Objectif**: Analyser la s√©curit√© d'une impl√©mentation RSA et comprendre pourquoi elle est inviolable.

**Contexte**: Vous avez r√©cup√©r√© un fichier `encrypted-data-rsa.txt` qui contient des donn√©es chiffr√©es avec la cl√© publique RSA. Mais pour d√©chiffrer, il faut la cl√© priv√©e...

**Votre mission**:
1. Analysez le fichier de donn√©es chiffr√©es
2. Cherchez dans le code source d√©compil√© s'il existe des failles
3. Analysez la cl√© publique extraite dans CTF-cle-publique

**Questions √† explorer et r√©pondre**:
- La cl√© priv√©e est-elle pr√©sente quelque part dans l'application? (V√©rifiez TOUS les fichiers)
- Y a-t-il un fichier de configuration qui pourrait contenir des cl√©s?
- Quelle est la taille de la cl√© RSA? Est-elle assez grande pour √™tre s√©curitaire?
- Expliquez pourquoi il est math√©matiquement impossible de casser cette cl√© publique pour retrouver la cl√© priv√©e
- Combien de temps faudrait-il pour factoriser le module n de cette cl√© avec les ordinateurs actuels?

:::info Ce que vous devez d√©montrer
Le but n'est PAS de r√©ussir √† d√©chiffrer (c'est impossible si c'est bien fait), mais de **prouver que vous comprenez pourquoi c'est impossible** et d'analyser la s√©curit√© de l'impl√©mentation.
:::

**R√©compense**: 3 points pour une analyse compl√®te et correcte.

**√Ä inclure dans votre rapport**:
- Recherche m√©thodique de la cl√© priv√©e (o√π avez-vous cherch√©?)
- Analyse de la cl√© publique (taille, module n, exposant e)
- Explication math√©matique de pourquoi on ne peut pas casser RSA 2048+ bits
- Estimation du temps de calcul n√©cessaire pour factoriser
- Conclusion: est-ce cassable ou non, et pourquoi?

---

## Temps pour le TP

Continuez √† travailler sur votre TP3.
